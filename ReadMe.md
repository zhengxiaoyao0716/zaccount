# 统一账户管理服务
## 既然每做个Web都要写用户管理，那么为何不单独做个工具呢

***
## 这个服务要纯净简单高效
必须保证完全摘除账户以外的业务逻辑

保持数据结构的简单高效，讨厌庞大与杂乱

数据必须易于报表查看，方便管理和迁移

应该充分考虑到安全性和可复用性

应同时兼容unix socket直接通讯

上一条决定了不能依赖于HTTP现有的机制

保持Go的 `一体化` 优势，即单二进制包部署


***
## 后台守护
> 这部分现在已经拆分到了 `zmodule` 里作为一个公共模块！

整合入daemon服务，目前看中了两个第三方开源库：[daemon](https://github.com/takama/daemon) [service](https://github.com/kardianos/service)
> 暂时放弃前者采用后者，前者在Windows上需要nssm支持才能运作。

~~在使用后者的过程中发现个问题，当应用以后台服务的方式运行时，参数貌似会丢失。目前尚且不知道这是不是只发生在Windows下。~~
> https://github.com/kardianos/service/issues/82#issuecomment-323494983
> 这个问题已解决，但我并不打算修改原有的设计，因为它附带解决了另外的问题（虽然也同时带来了一点复杂度）

目前我设计的解决方案是是，将启动参数写入文件，并在服务中再次读取。这是比较合理的，因为它顺带解决了一个比较常见的问题：我总是忘记上次启动某个程序的参数~

呃，这个方法有个致命缺点：容易暴露关键参数！ 比如密码密钥什么的。。。所以，如果你需要的参数很机密，请尽量另行想办法处理。。。

***
## 可配置
要作为一个独立可复用的模块，可配置性很关键。具体来讲，监听什么服务，暴露哪些接口，具体运行时的参数等都需要可配置。

另一方面，加入配置实际上是引入了人为的参与环节，一定程度上可以弥补代码开源带来的隐秘性缺失问题。

***
## 安全问题
由于代码开源，安全性是个问题。但我相信这是可以解决并且应该解决的，正如 柯克霍夫 说的， `密码系统应该就算被所有人知道系统的运作步骤，仍然是安全的。`
> 所以我不止开源代码，还要公开的、仔细的阐明我的加密策略，我认为广大开源者们的智慧的集合要远超越于少数的骇客，大家一起改进这套策略才是最安全的。

### 数据安全
主要是用户密码等的安全。根据 [这里](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016) 的对比，argon2 似乎是当前最佳的选择。

但由于国内的滞后，几乎搜不到相关的文章，而且在Golang里似乎也尚未给出一个官方的支持，所以不是很敢放手去用。

为此，我准备了另一套基于Bcrypt的方案作为替代，事实上在我搞明白Argon2之前，它也是默认情况下的选择。下面是具体设计：
> （参考 [Dropbox的方案](https://blogs.dropbox.com/tech/2016/09/how-dropbox-securely-stores-your-passwords/) ，[中文翻译](http://www.jianshu.com/p/5fa8289c9249)）
- 将用户密码通过SHA512算法转换成一个哈希值
- 使用Bcrypt算法再hash，默认工作因子为 `bcrypt.DefaultCost` (10)
- 使用AES256对hash加密，全局密钥（pepper）可配置

总得来说，对照原文译文，没什么难理解的，但最后一环，采用AES而不是hash的原因，原文没有解释清楚，那篇翻译大概也有点问题。
> 原文只说了 `we can’t easily rotate it` ，这是废话，hash的特点就是不可逆，AES特点则是可逆，这不能成为放弃hash选择AES的理由。

我推测，从 `泄露的可能性` + `不能反解` 到放弃hash的方案，其中应该还有一环没说清楚。我脑补一下大概是这样：
> 由于存在泄露的可能，所以在pepper泄露后，必须有能力将原密文（经过了sha512和bcrypt处理后的）反解，从而再采用更换pepper之类来进行补救，所以不能反解的hash方案被否决。

基于这些分析，我觉得我的设计里就还须加上一环：提供一个接口，使得管理员可以更换全局密钥，而不丢失数据信息

但这个pepper怎么保存目前我没什么想法，先交给大家自己管理吧。

另外，我也不打算完全放弃Argon2，对比了几个开源的Go的实现，我选择 [这个](https://github.com/magical/argon2) 作为直到官方支持前的解决方案。

之所以选择它而不是另外几个开源实现，是因为这个是完全用Go语言实现的，无需外部的依赖和绑定，相对来说不会给项目带来太大复杂性。

然而这个库（或者说是Argon2d？）并没有负责生成和管理salt（这也是我选择Bcrypt作为默认策略的原因）。对此我的策略是，生成随机salt，hash后加在密码后面。。。

我知道这大概不是个很好的办法，但比较方便。毕竟Argon2暂时没得到Go的官方支持，以后就不一定了，我不想现在做很多等以后发现没用了的事情。


### 连接安全
> 这部分拆分到 `zcli` 里做为一个公共模块

后台进程会开启一个服务，根据监听地址决定采用tcp还是Unix Sock，当然Windows下只能用tcp。不提供原生http和websocket支持，后续可以做插件封装转发。

以后开启的控制进程通过这个服务与后台交互，~~只能保持一条管理连接（可写），但可以保持多条监控连接（可读）。管理连接可以查看和关闭其它连接~~ 采取更精密的Mode标识符权限位。

安全模块应该是可选的，默认关闭。开启的话，需要有一个统一账户管理服务做支持（对于zaccount来说就是它自身），密码存储等机制参见数据安全那段。

控制进程可以直接访问数据，其它远程http之类的连接只能访问暴露的公开接口。控制进程可以修改接口权限和状态，比如是否开放注册等。

传输的安全性比较麻烦，以前用Go写过一个NSSK协议的实现，但现在想一想也没多大实际作用。干脆不管它了，如果要保证数据传输过程安全，自行封装https之类的罢。


***
## 通信与连接
大概是因为一开始就决定了要采用与现有常见架构完全不同的方式，来组织我的代码吧，越写越觉得现在的很多东西很不合理

具体到通信与连接，我们现在拥有很多的协议与手段：`tcp`, `udp`, `unix-socket`, `http`, `websocket` ...

但这合理吗？我的意思是说，从顶层开发的角度来说，需要知道这么多通信协议吗？这些底层的东西在现代开发中真的做到透明化了吗？

我认为没有。如果做到了，我们就应该可以简单的将一个项目在上面的底层机制中任意切换，但很显然我们今天不能把一个基于http的项目简单的转移到tcp上。

（注意我明白各种协议有自己具体的应用场景和优劣，我这里说的是指，开发者应该可以简单的选择用什么协议传输自己的数据，就能得到相应的好处，而不必为此修改自己传输的内容的格式）

（这么一想其实早期socket开发，都是可以用参数选择协议（STREAM|DGRAM之类），就是种比较好的方案）

如果是传统web开发，基于http协议的一些特有特性没什么不可，但现代Web开发中，Http扮演的角色越来越小，它不再是必要的。

比如一个提供Restful数据服务的后端，它有必要基于http吗？现在不少网站直接用WebSocket提供数据，Http本身的ContentType之类的Header在这里根本用不到。

虽说Websocket也是架设在Http上层的，但其实只要实现相同的机理，在浏览器无关的环境里，我们完全可以直接用其它双向通信的，具备长连接能力的协议代替Websocket。

所以在我看来Websocket这种协议比Http高明多了，没有那么多自己定义的“私货”，一个基于Websocket良好设计的服务是可以简单的转移到别的协议上去的。

于是，我决定自己包装一层顶层通信机制，它的底层可以基于任何一种通用协议。但这个机制不是强行的统一各个协议，事实上有些协议本身是不太适合同一到一起的。

理由わ？不同的项目，对通信的需求不同。具体来说，有的需要的是长连接，需要服务端与客户端双向通信的能力，有的需要的是无状态通信，客户端向服务端发出一次性请求。

这两种不同方式各有用途，其它的各种乱七八糟的协议，本质无非就是完成这两种通信需求之一。我将分别提取它们共通之处，构造一个最简的，没有干扰的机制。下面开始设计：

### 长连接，connect
> 既然是长连接，连接具有状态，那么连接就应该是“主体”。也就是说，应该有个 `conn` 对象，对象的新建和删除对应连接的开关，而读写方法都可以委托给这个对象。

### 单请求，request
> 既然是单请求，连接本身就不重要了，应该以请求本身为主体，请求发起和响应携带消息，只能由一端发起，另一端进行响应，一次请求结束连接即销毁。
